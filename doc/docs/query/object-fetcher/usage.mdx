---
sidebar_position: 1
title: Basic Usage
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ViewMore } from '@site/src/components/ViewMore';
import { DtoExplosion } from "@site/src/components/Image";

## Why Introduce Object Fetchers

Before understanding object fetchers, it is necessary to first understand conventional attribute queries.

For example, I need a SQL like this:

```sql
select 
    b.id,
    b.name,
    b.edition
    /* Don't need `b.price` and `b.store_id` */
from book b
where b.edition = 3; 
```

In this SQL, we only query some columns. The corresponding Jimmer code is:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
BookTable table = BookTable.$;
List<Tuple3<Long, String, Integer>> tuples = sqlClient
    .createQuery(book) 
    .where(table.edition().eq(3))
    // highlight-next-line 
    .select(
        table.id(),
        table.name(),
        table.edition() 
    )
    .execute();
System.out.println(tuples);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">  

```kotlin
val tuples = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3)) 
        // highlight-next-line
        select(
            table.id
            table.name
            table.edition
        )
    }
    .execute()
println(tuples) 
```

</TabItem>
</Tabs>

The printed output is *(formatted for readability)*:
```
[
    {
        "_1" : 3,
        "_2" : "Learning GraphQL",
        "_3" : 3
    }
    ...Other objects omitted  
]
```

:::info
Since only some object properties are queried, `select(table)` cannot be simply used. Instead, `select(expr1, expr2, ..., expr3)` is required.

However, this results in tuples being returned instead of Book objects.  
:::

In the tuples, the attribute order corresponds to the `select()` order. In the above example, the mapping in each tuple is:  

```
_1 -> id
_2 -> name
_3 -> edition
```

If we want to return objects, we must define a BookDTO type *(assuming lombok is used for Java)*:

Unlike the original `Book` entity type, `BookDTO` only contains the properties we need rather than all properties.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookDTO.java"
@Data
public class BookDTO {
    private long id;
    private String name; 
    private int edtion;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookDTO.kt" 
data class BookDTO(
    val id: Long,
    val name: String,
    val edition: Int
)
```

</TabItem>
</Tabs> 

There are two ways to convert the tuples to `BookDTO` objects:

-   Keep previous code unchanged, first query `Tuple3<Long, String, Integer>` collection, then convert using Stream API

-   Use Jimmer's utility API to directly transform the query result

Here we use the second approach:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable table = BookTable.$;
List<BookDTO> bookDTOs = sqlClient
    .createQuery(book)
    .where(table.edition().eq(3))
    .select(
        table.id(),
        table.name(),
        table.edition()
    )
    // highlight-next-line
    .map(tuple -> {
        BookDTO dto = new BookDTO();
        dto.setId(tuple.get_1());
        dto.setName(tuple.get_2());
        dto.setEdition(tuple.get_3());
    }); 
System.out.println(bookDTOs);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val bookDTOs = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.id
            table.name
            table.edition
        )
    }
    // highlight-next-line
    .map {
        BookDTO(it._1, it._2, it._3)
    }
println(tuples)
```

</TabItem>
</Tabs>  

The result after conversion is the type we want:

```
[
    {
        "id" : 3, 
        "name" : "Learning GraphQL",
        "edition" : 3
    }
    ...Other objects omitted
]
```

Although JPA and MyBatis have their own sets of mapping methods, both have limitations:

-   For JPA, it returns all object properties by default. To customize returned properties:
  
    -   Use HQL or interfaces
    
    -   Or use `query.unwrap(SQLQuery.class).setResultTransformer(Transformers.aliasToBean(DTO.class))`
    
-   MyBatis needs to write type mappings in XML. MyBatis-Plus provides some wrappers to simplify this process.

However, neither JPA nor MyBatis nor MyBatis-Plus can avoid having to write an extra DTO class. Next we'll use object fetchers to simplify this process.
  
:::info
Unfortunately, query requirements are often diverse. Formats diversification inevitably leads to more DTO types *(as the aggregate root type, format diversification is likely; as associated types of other DTOs, diversification is even more likely)*.

This ultimately results in <ViewMore buttonText="DTO explosion" variant="text"><DtoExplosion/></ViewMore>  
:::
  
## Using Object Fetchers
  
For each entity interface, Jimmer generates a corresponding Fetcher class. These Fetchers are object fetchers.
  
Based on the fetched properties, object fetchers automatically package objects, eliminating the need to manually map and write additional DTO classes.

### Fetch Specified Properties

:::note
The Annotation processor will automatically generate a Fetcher class for each entity interface, which is `BookFetcher` in this example. 
:::
  
The query in the above example can be written using object fetchers as:

<Tabs groupId="language"> 
<TabItem value="java" label="Java">

```java  
BookTable table = BookTable.$;
List<Book> books = sqlClient.createQuery(table)
        .where(table.edition().eq(3))
        .select(
            // highlight-next-line
            table.fetch(
                BookFetcher.$
                    // id is implicit and mandatory  
                    .name()
                    .edition()
            )
        )
        .execute();
System.out.println(books); 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            // highlight-next-line
            table.fetchBy {
                // id is implicit and mandatory
                name
                edition
            }
        )
    }
    .execute()
println(books)
```

</TabItem>
</Tabs>
  
We can see the return type is `Book` directly, without needing further mapping, saving a lot of time in daily coding.
  
The output is:

```json
[
    {
        "id" : 3,
        "name" : "Learning GraphQL",
        "edition" : 3
    }
    ...Other objects omitted
] 
```
  
In Jimmer, for query output formats, there is absolutely no <ViewMore buttonText="DTO explosion" variant="text"><DtoExplosion/></ViewMore>. Combined with Jimmer entity [dynamics](../../object/dynamic), an object of arbitrary shape can be easily expressed.
  
For example, we can modify the code to not fetch book edition, but book price:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable table = BookTable.$;
List<Book> books = sqlClient.createQuery(table)
        .where(table.edition().eq(3))
        .select(
            // highlight-next-line
            table.fetch(
                BookFetcher.$
                    .name()  
                    .price()
            )
        )
        .execute();
System.out.println(books);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin  
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            // highlight-next-line
            table.fetchBy {
                name
                price 
            }
        )
    }
    .execute()
println(books)
```

</TabItem> 
</Tabs>
  
The JSON output is now:

```json
[
    {
        "id" : 3,
        "name" : "Learning GraphQL", 
        "price" : 51.00
    }
] 
```
  
:::tip
With Jimmer entity [dynamics](../../object/dynamic), extra DTOs and mappings are no longer needed. Just change the object fetcher properties.
  
For query output, eliminating <ViewMore buttonText="DTO explosion" variant="text"><DtoExplosion/></ViewMore> can greatly improve server-side productivity.
:::
  
### Fetch All Properties
  
The above approach has a problem. If many properties need to be queried, fetching each manually can be very tedious.
  
:::info  
This is also one problem with [GraphQL](https://graphql.org/).
:::
  
To solve this, Jimmer also provides the following two APIs for quickly fetching many properties.
  
Since these will be explained in detail in subsequent docs, only the links are provided here. The two APIs are:
  
-   `allScalarFields`
    
    Fetch all scalar properties, excluding associative, computed, and view properties.
    
    See [Fetch All Scalar Properties](./props#fetch-all-scalar-properties) for details.
    
-   `allTableFields`

    Fetch all properties defined in the table, including all scalar properties and one-to-one/many-to-one properties based on foreign keys, but excluding one-to-many, many-to-many, one-to-one/many-to-one associations based on join tables, computed properties, and view properties.
    
    See [Fetch All Table-defined Properties](./association#fetch-all-table-defined-properties) for details.
    
See also [Differences between the two](./association#differences-between-allscalarfields-and-alltablefields).
  
## Differences from JPA
  
When object fetchers are used to fetch associative properties *(discussed in subsequent docs, not demonstrated here)*, they are similar to [JPA's EntityGraph](https://www.baeldung.com/jpa-entity-graph), but have the following differences:
  
-   Object fetchers use `batch-load` strategy to load associated objects, not JPA's `join-fetch` concept. This is important because:

    -   Fetching collection associations [does not break paginated queries](https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html) like [JPA's EntityGraph](https://www.baeldung.com/jpa-entity-graph).
    
    -   More friendly to [association caching](../../cache/cache-type/association) and [remote associations](../../spring/spring-cloud).
    
-   JPA's EntityGraph only controls associative properties, but object fetchers can control any properties, same as GraphQL, with precision down to each property.
  
-   For infinite recursive structures caused by self-referencing properties, object fetchers support [recursive querying](./recursive).
