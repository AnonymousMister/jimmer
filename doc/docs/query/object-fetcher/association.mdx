---
sidebar_position: 3
title: Associations  
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ViewMore } from '@site/src/components/ViewMore';
import FilterRef from './_filter-ref.md';

## Fetching Associated Objects

In [last doc](./props) we introduced scalar property fetching. In this doc we discuss association fetching.

### Fetching Associated Objects With Only id  

When fetching an association without any parameters, the associated object only has the `id` property.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;

List<Book> books = sqlClient
    .createQuery(book)
    .select(
        book.fetch(
            BookFetcher.$.
                .allScalarFields()
                // highlight-next-line
                .authors()
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                allScalarFields()
                // highlight-next-line
                authors()
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

Here `authors` fetches the many-to-many association. We did not specify any parameters for `authors()`, meaning fetching only the `id` property of associated objects.

Two SQLs are generated:

1.  Query for the `Book` objects themselves:

    ```sql
    select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE,
        tb_1_.STORE_ID
    from BOOK as tb_1_
    where tb_1_.EDITION = ? 
    ```

2.  Query for all `Author` objects with only `id` based on association `Book.authors`:

    ```sql
    select
        tb_1_.BOOK_ID, /* batch-map key */
        tb_1_.AUTHOR_ID /* batch-map value */
    from BOOK_AUTHOR_MAPPING as tb_1_
        where tb_1_.BOOK_ID in (?, ?, ?, ?) 
    ```

:::info
There are two associations for `Book`, `Book.store` and `Book.authors`. `Book.authors` is chosen here for a reason. 

`Book.store` is a direct many-to-one association mapped by foreign key. When fetching it with only id and no <ViewMore buttonText="filters" variant="text"><FilterRef/></ViewMore>, the associated id is just the foreign key `store_id` of the current table. So there would only be one SQL instead of two here.

Therefore `Book.authors` has better demo effect for this example, `Book.store` will be shown in next example.  
:::

This example illustrates:

-   The query only needs id of associated objects, and no filters are used (filters will be introduced later).

    Jimmer optimizes this case by querying only the association table `BOOK_AUTHOR_MAPPING` without querying the `AUTHOR` table.

-   `where tb_1_.BOOK_ID in (?, ?, ?, ?)` is batch query because the first query returns 4 main objects.

    Jimmer uses batch query to solve the `N+1` problem, same as `DataLoader` in GraphQL.

    When a batch becomes too large, jimmer-sql will split it into multiple batches. This will be explained in [Batch Size](#batch-size) section below.
  
-   Jimmer queries associated objects via additional SQL instead of LEFT JOIN in main query SQL.

    This is designed to prevent duplication in query results when joining on collection associations, as such duplications can be devastating for paged queries. 

The printed result is (formatted for readability):

```json
{
    "id":3,
    "name":"Learning GraphQL",
    "edition":3,
    "price":51.00,
    // highlight-next-line  
    "authors":[
        {"id":1},
        {"id":2}
    ]
}
...omit 2nd object...,  
...omit 3rd object...,
...omit 4th object...
```

### Fetching Complete Associated Objects

In this example, we fetch the many-to-one association `Book.store` and specify parameters for `store()` to explicitly request all scalar properties of the associated object.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
BookTable book = BookTable.$;
List<Book> list = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
            BookFetcher.$
                .allScalarFields()
                // highlight-next-line
                .store(
                    BookStoreFetcher.$
                        // highlight-next-line
                        .allScalarFields()
                )
        )
    )
    .execute();
System.out.println(toJson(list));
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient
.createQuery(Book::class) {
    where(table.edition.eq(3))
    select(
        table.fetchBy {
            allScalarFields()
            // highlight-next-line
            store {

                // highlight-next-line
                allScalarFields()
            }
        }
    )
}
.execute()
```

</TabItem>
</Tabs>

Two SQLs are generated:

-   Query for `Book` objects:

    ```sql
    select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE,
        tb_1_.STORE_ID
    from BOOK tb_1_ 
    where tb_1_.EDITION = ?
    ```

-   The `STORE_ID` values from previous step are deduplicated and there are two values. Query the associated `BookStore` objects for them:

    ```sql
    select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.WEBSITE
    from BOOK_STORE tb_1_
    where tb_1_.ID in (?, ?) 
    ```

The output is:
```json  
[
    {
        "id": 3,
        "name": "Learning GraphQL",
        "edition": 3,
        "price": 51.00,
        // highlight-next-line
        "store": {
            "id": 1,
            "name": "O'REILLY",
            "website": null
        }
    }
    ...omit other objects
]
```

### Fetch All Table-defined Fields 

In some cases all table-defined fields need to be fetched. Use `allTableFields` for this.

`allTableFields` fetches all properties defined in the table, including all scalar properties and foreign key based one-to-one/many-to-one associations, but not collection associations, one-to-one/many-to-one associations based on join tables, computed properties or view properties.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
BookTable book = BookTable.$;
List<Book> list = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
            BookFetcher.$
                // highlight-next-line
                .allTableFields()
        )
    )
    .execute();
System.out.println(toJson(list));
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val bookAllTableFields = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                // highlight-next-line
                allTableFields()
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

The output is: 

```json
[
    {
        "id": 3,
        "name": "Learning GraphQL",
        "edition": 3,
        "price": 51.00,
        "store": {
            "id": 1
        }
    }
    ...omit other objects
]
```

:::info
Although `allTableFields` includes foreign key based one-to-one/many-to-one associations, for this example:  

`allTableFields` = `allScalarFields` + `store`

However, only the `id` property of associated objects is fetched.  

The literal meaning of `allTableFields` is querying all fields of the current table. When querying only one table, only `id` of associated objects is known since `id` is the foreign key in current table.
:::

In some cases, `select(table.fetch(XxxFetcher.$.allTableFields()))` is equivalent to `select(table)`. The latter can be seen as a shorthand for the former. 

:::caution  
Equivalence prerequisite: Associations are not affected by <ViewMore buttonText="filters" variant="text"><FilterRef/></ViewMore>
:::

The simpler equivalent form is:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;
List<Book> list = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    // highlight-next-line
    .select(book)  
    .execute();
System.out.println(toJson(list)); 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val bookAllScalarFields = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        // highlight-next-line
        select(table)
    }
    .execute()

```

</TabItem>
</Tabs>


## Differences between allScalarFields and allTableFields

Since fetching all scalar fields and all table-defined fields are very common, writing each property repeatedly would be tedious. So Jimmer provides two APIs to simplify this process.

Note that:
-   `allScalarFields` only fetches scalar properties, no associations, computed or view properties.

-   `allTableFields` fetches all fields defined in table, including foreign key based one-to-one/many-to-one associations, but not collections, many-to-one/one-to-one associations based on join tables, computed or view properties.

For `Book` discussed in this doc, there is a many-to-one property `Book.store` mapped directly by foreign key instead of through join table. So 

`allTableFields` = `allScalarFields` + `store`

Here are two examples:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java

BookTable book = BookTable.$;

List<Book> booksWithScalarFields = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
            BookFetcher.$
                .allScalarFields() ❶
        )
    )
    .execute();


List<Book> booksWithTablesFields = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
            BookFetcher.$
                .allTableFields() ❷
        )
    )
    .execute();

System.out.println(booksWithScalarFields);
System.out.println(booksWithTablesFields); 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val booksWithScalarFields = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                allScalarFields() ❶
            }
        )
    }
    .execute()

val booksWithTableFields = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                allTableFields() ❷
            }
        )
    }
    .execute()

println(booksWithScalarFields)
println(booksWithTablesFields)
```

</TabItem>
</Tabs>

The output is:
```
[ ❶
    {
        "id": 3,
        "name": "Learning GraphQL",
        "edition": 3,
        "price": 51.00
    }
    ...omit other objects
]
[ ❷
    {
        "id": 3,
        "name": "Learning GraphQL",
        "edition": 3,
        "price": 51.00,
        "store": {
            "id": 1
        }
    }
    ...omit other objects
] 
```

Comparing the outputs, `allScalarFields` contains only scalar properties without any associations, while `allTableFields` additionally includes the `store` association based on `allScalarFields`.

## Special Configurations for Associations

### BatchSize

For one-to-many/many-to-many associations, a large number of associated objects may impact application performance. The `batchSize` configuration is provided for management.

The following example does not configure `batchSize`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java  
BookTable book = BookTable.$;
List<Book> list = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
                BookFetcher.$.allScalarFields()
                // highlight-next-line
                .authors(AuthorFetcher.$.allScalarFields())
        )
    )
    .execute();
System.out.println(toJson(list));
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                allTableFields()
                authors {
                    // highlight-next-line
                    allScalarFields()
                }
            }
        )
    }
.execute()
```

</TabItem>
</Tabs>

The generated SQL is:
```sql  
# 1. Query book table to get all BOOK_ID
select
    tb_1_.ID,
    tb_1_.NAME,
    tb_1_.EDITION,
    tb_1_.PRICE
from BOOK tb_1_
where tb_1_.EDITION = ?

# 2. Use BOOK_ID from previous step to join query author table
select
    tb_2_.BOOK_ID,
    tb_1_.ID,
    tb_1_.FIRST_NAME,
    tb_1_.LAST_NAME,
    tb_1_.GENDER
from AUTHOR tb_1_
inner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID
where tb_2_.BOOK_ID in (?, ?, ?, ?)
```

In the SQL, no `batchSize` is configured so the default will be used. All BOOK_ID will be directly used in the `in(...)` list of the second query.

The output is:
```json
[
    {
        "id": 3,
        "name": "Learning GraphQL",
        "edition": 3,
        "price": 51.00,
        "authors": [
            {
                "id": 1,
                "firstName": "Eve",
                "lastName": "Procello",
                "gender": "FEMALE"
            },
            {
                "id": 2,
                "firstName": "Alex",
                "lastName": "Banks",
                "gender": "MALE"
            }
        ]
    },
    ...omit other objects
]

```

In the example above, we see the query:
```sql
select
    tb_2_.BOOK_ID,
    tb_1_.ID,
    tb_1_.FIRST_NAME,
    tb_1_.LAST_NAME,
    tb_1_.GENDER
from AUTHOR tb_1_
inner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID  
where tb_2_.BOOK_ID in (?, ?, ?, ?)
```

Here, the `in` expression implements batch query to solve `N+1` problem.

If a batch is too large, it will be split into multiple batches based on `batchSize` configuration, such as:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;
List<Book> list = sqlClient.createQuery(book)
    .where(book.edition().eq(3))
    .select(
        book.fetch(
                BookFetcher.$.allScalarFields()
                // highlight-next-line
                .authors(AuthorFetcher.$.allScalarFields(), it -> it.batch(2))
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">  

```kotlin
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            table.fetchBy {
                allScalarFields()
                authors({
                    // highlight-next-line
                    batch(2)
                }) {}
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

:::danger
Here the `batchSize` for `authors` is set to 2. Such a small value would cause poor performance, it is only for demo purposes. Please do not use such small values in real projects.
:::

This would cause the `in(?, ?, ?, ?)` to be split into two `in(?, ?)`, and the SQL to fetch associated objects would be split into two.

1.  
```sql
select
    tb_2_.BOOK_ID,
    tb_1_.ID,
    tb_1_.FIRST_NAME,
    tb_1_.LAST_NAME, 
    tb_1_.GENDER
from AUTHOR tb_1_
inner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID
where tb_2_.BOOK_ID in (?, ?) 
```

2.
```sql  
select
    tb_2_.BOOK_ID,
    tb_1_.ID,
    tb_1_.FIRST_NAME,
    tb_1_.LAST_NAME,
    tb_1_.GENDER
from AUTHOR tb_1_
inner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID
where tb_2_.BOOK_ID in (?, ?)
```

In real projects, in most cases `batchSize` would not be configured like this at fetcher level. Instead, use the global configurations in `SqlClient`: 

1.  `JSqlClient.getDefaultBatchSize()`: Default `batchSize` for one-to-one and many-to-one associations, default 128
2.  `JSqlClient.getDefaultListBatchSize()`: Default `batchSize` for one-to-many and many-to-many associations, default 16

When creating `SqlClient`, the global configs can be changed:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
JSqlClient sqlClient = JSqlClient
    .newBuilder()
    .setDefaultBatchSize(256) 
    .setDefaultListBatchSize(32)
    ....
    build();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin  
val sqlClient = newKSqlClient {
    setDefaultBatchSize(256)
    setDefaultListBatchSize(32)
    ....
    }
```

</TabItem>
</Tabs>  

:::caution
No matter association-level `batchSize` or global `batchSize`, do not set above 1000 because Oracle database allows max 1000 values in `in(...)`.
:::


### Pagination at Association Level

For collection associations, `limit(limit, offset)` can be specified during fetching to do pagination at association level.

:::caution
Association-level pagination and batch loading cannot coexist. Association-level pagination necessarily causes `N+1` problem. Please use this feature cautiously!

If association-level pagination is used, `batchSize` must be set to 1, otherwise exceptions would be thrown. This is designed to make it clear to developers and readers that the code has `N+1` performance risk.
:::

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
BookTable book = BookTable.$;

List<Book> books = sqlClient
    .createQuery(book)
    .select(
        book.fetch(
            BookFetcher.$
            .allScalarFields()
            .authors(
                AuthorFetcher.$.allScalarFields(),
                // highlight-next-line
                it -> it.batch(1).limit(/*limit*/ 10, /*offset*/ 90)
            )
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(
            // highlight-next-line
            table.fetchBy {
                allScalarFields()
                authors({
                    batch(1)
                    // highlight-next-line
                    limit(limit = 90, offset = 10)
                    }) {
                    allScalarFields()
                }
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

-   Since association pagination cannot solve `N+1` problem, multiple SQLs are generated
-   For simplicity let's assume `H2Dialect` is used so different databases have the same paging SQL

1.  Query current `Book` objects
    ```sql   
    select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE
    from BOOK as tb_1_
    where tb_1_.EDITION = ?
    ```

2.  Paginated query on `authors` collection of the 1st `Book` object 
    ```sql
    select
        tb_1_.AUTHOR_ID,
        tb_3_.FIRST_NAME,
        tb_3_.LAST_NAME, 
        tb_3_.GENDER
    from BOOK_AUTHOR_MAPPING as tb_1_  
    inner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID
    where tb_1_.BOOK_ID = ?
    /* highlight-next-line */
    limit ? offset ?  
    ```

3.  Paginated query on `authors` collection of the 2nd `Book` object

    Same as above, omitted.

4.  Paginated query on `authors` collection of the 3rd `Book` object 

    Same as above, omitted.

4.  Paginated query on `authors` collection of the 4th `Book` object

    Same as above, omitted.

### Property-level Filters

When fetching associations, filters can be specified to filter associated objects.

Here for comparison, the query selects two columns, both are `Book` type. 

-   The `Book.authors` of the first column uses filter
-   The `Book.authors` of the second column does not use filter

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookTable book = BookTable.$;

List<Tuple2<Book, Book>> books = sqlClient
    .createQuery(book)
    .select(
        // First column  
        book.fetch(
            BookFetcher.$
            .allScalarFields()
            .authors(
                AuthorFetcher.$.allScalarFields(),

                // Use filter
                // highlight-next-line
                it -> it.filter(args -> {
                    args.where(args.getTable().firstName().ilike("a"));
                })
            )
        ),

        // Second column
        book.fetch(
            BookFetcher.$
                .allScalarFields()
                .authors(
                    AuthorFetcher.$.allScalarFields()
                // No filter used
                )
        )
    )
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val tuples: List<Tuple2<Book, Book>> = sqlClient
    .createQuery(Book::class) {
        where(table.edition.eq(3))
        select(

            // First column
            table.fetchBy {
                allScalarFields()
                authors({
                    // Use filter
                    // highlight-next-line
                    filter {
                    where(table.firstName ilike "a")
                    }
                }) {
                    allScalarFields()
                }
            },

            // Second column
            table.fetchBy {
                allScalarFields()
                authors { // No filter used  
                    allScalarFields()
                }
            }
        )
    }
.execute()
```

</TabItem>
</Tabs>

Three SQLs are generated:

1.  Query the two `Book` objects needed for the tuple

    ```sql
    select

    /* For tuple._1 */  
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE,

    /* For tuple._2 */
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION, 
        tb_1_.PRICE

    from BOOK as tb_1_ 
    where tb_1_.EDITION = ?
    ```

2.  For the `authors` association of the 4 `Book` objects in column 1, use filter
    ```sql   
    select

        tb_1_.BOOK_ID,
        tb_1_.AUTHOR_ID,
        tb_3_.FIRST_NAME,
        tb_3_.LAST_NAME,
        tb_3_.GENDER
    from BOOK_AUTHOR_MAPPING as tb_1_
    inner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID 
    where
        tb_1_.BOOK_ID in (?, ?, ?, ?)  
    and
        /* Use filter here */
        /* highlight-next-line */
        lower(tb_3_.FIRST_NAME) like ?
    ```

3.  For the `authors` association of the 4 `Book` objects in column 2, no filter
    ```sql
    select

        tb_1_.BOOK_ID,
        tb_1_.AUTHOR_ID,
        tb_3_.FIRST_NAME,
        tb_3_.LAST_NAME,
        tb_3_.GENDER
    from BOOK_AUTHOR_MAPPING as tb_1_
    inner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID
    where
        tb_1_.BOOK_ID in (?, ?, ?, ?)
    /* No filter here */ 
    ```

The printed result is (formatted for readability):
```json 
Tuple2{
    _1={
        "id":3,
        "name":"Learning GraphQL",
        "edition":3,
        "price":51.00,

        // Filter used, incomplete collection
        // highlight-next-line
        "authors":[
            {
                "id":2,
                "firstName":"Alex",
                "lastName":"Banks",
                "gender":"MALE" 
            }
        ]
    },
    _2={
        "id":3,
        "name":"Learning GraphQL",
        "edition":3,
        "price":51.00,

        // No filter, complete collection 
        // highlight-next-line
        "authors":[
            {
                "id":2,
                "firstName":"Alex",
                "lastName":"Banks",
                "gender":"MALE"
            },{
                "id":"fd6bb6cf-336d-416c-8005-1ae11a6694b5",
                "firstName":"Eve",
                "lastName":"Procello",
                "gender":"MALE"
            }
        ]
    }
}
```

:::note
Filters can not only filter associated objects, but also sort them. The principle is similar so not demonstrated here. 
:::

:::caution

1.  For associations satisfying both below conditions, applying filters would cause exceptions:
    -   Many-to-one
    -   Not null

2.  After field filters are used, [association cache](../../cache/cache-type/association) for that field becomes invalid. 

    To keep association cache valid, global filters supporting [multi-view cache](../../cache/multiview-cache) can be used.

3.  A common mistake in real development (Java for example) is:

    `filter(it -> args.getTable().firstName().ilike("a"))`

    This creates the condition expression but does not call `args.where`. Filter code not calling either `args.where` or `args.orderBy` is meaningless.

    The correct code is:

    `filter(it -> args.where(args.getTable().firstName().ilike("a")))`
:::
