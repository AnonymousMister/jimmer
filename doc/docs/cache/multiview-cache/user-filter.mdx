---
sidebar_position: 3
title: Support Custom Filters
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Cache-friendly Filters

### Basic Concepts

In the [User-defined Filters](../../query/global-filter/user-filter) documentation, we introduced that custom global filters need to implement the `Filter/KFilter` interface.

However, ordinary filters defined using this interface are not cache-friendly. 

Taking the `Book` entity as an example, if a cache-unfriendly global filter is set for it, it will cause all the following filter-sensitive properties

-   Association properties targeting `Book`, such as `BookStore.books`, `Author.books`

-   Computed properties relying on the above association properties, such as `BookStore.avgPrice`, `BookStore.newestBooks`

to become uncacheable.

Jimmer uses the `CacheableFilter/KCacheableFilter` interface to define cache-friendly filters:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="CacheableFilter.java"
package org.babyfish.jimmer.sql.filter;

import org.babyfish.jimmer.sql.ast.table.Props;
import org.babyfish.jimmer.sql.event.EntityEvent;

import java.util.SortedMap;

public interface CacheableFilter<P extends Props> extends Filter<P> {

    SortedMap<String, Object> getParameters();

    boolean isAffectedBy(EntityEvent<?> e);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="KCacheableFilter.kt"
package org.babyfish.jimmer.sql.kt.filter

import org.babyfish.jimmer.sql.event.EntityEvent
import java.util.*

interface KCacheableFilter<E: Any> : KFilter<E> {

    fun getParameters(): SortedMap<String, Any>?

    fun isAffectedBy(e: EntityEvent<*>): Boolean
}
```

</TabItem>
</Tabs>

This interface inherits from `Filter/KFilter` and adds two new methods:

-   `getParameters`: The SubKey fragment contributed by this filter for multi-view cache. 

-   `isAffectedBy`: Accepts an event that the filtered entity is modified, and judges whether the filtering fields depended on by the current filter are changed.

:::info
An entity type allows being processed by multiple global filters. If there are multiple global filters:

-   If any one of them is cache-unfriendly, it will cause other filter-sensitive properties to become uncacheable.

    Therefore, these global filters must either all be cache-unfriendly `Filter/KFilter`, or all be cache-friendly `CacheableFilter/KCacheableFilter`. Mixing them together makes no sense.

    If such meaningless mixing occurs accidentally, Jimmer will tell [why caching is disabled](./abandoned-callback). 

-   When all global filters are cache-friendly, the data returned by the `getParameters()` method of all `CacheableFilter/KCacheableFilter` objects is merged together as the `SubKey` of the multi-view cache.

    For example, if an entity is processed by two global filters at the same time. One is the filter implied by [logical delete](../../query/global-filter/logical-deleted), denoted as `a`; the other one is a user-defined filter, denoted as `b`. 

    Assume 

    - `a`'s `getParameters()` returns `{"logicalDeleted":false}`

    - `b`'s `getParameters()` returns `{"tenant":"a"}`
    
    Then the final `SubKey` in multi-view cache will be 
    
    `{"logicalDeleted":false,"tenant":"a"}`
:::

### Logical Delete Revisited

In the previous article [Support Built-in Filters](./builtin-filter), we talked about the `useMultiViewCache` parameter of `@LogicalDeleted` annotation. The default value is `false`. To make all filter-sensitive properties cacheable, `useMultiViewCache` must be configured as `true`. This is very important.

Now we can explain this.

-   If `useMultiViewCache` of `@LogicalDeleted` is `false`, the corresponding built-in filter only implements the `Filter/KFilter` interface and is cache-unfriendly.

-   If `useMultiViewCache` of `@LogicalDeleted` is `true`, the corresponding built-in filter only implements the `CacheableFilter/KCacheableFilter` interface and is cache-friendly.

### Define Cache-friendly Filters 

In the [User-defined Filters](../../query/global-filter/user-filter) documentation, we defined a super type `TenantAware` for entities. Let's review its code again:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="TenantAware.java"
@MappedSuperclass
public interface TenantAware {

    String tenant();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="TenantAware.kt"
@MappedSuperclass
interface TenantAware {

    val tenant: String
}
```

</TabItem>
</Tabs>

Any entity type that needs to support multiple tenants can inherit `TenantAware`, such as `Book`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book extends TenantAware {

    ...code omitted...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt" 
@Entity
interface Book : TenantAware {
    
    ...code omitted...
}
```

</TabItem>
</Tabs>

Assume there is an object of type `TenantProvider` in the Spring context. Its Java method `get()` and Kotlin property `tenant` are used to extract the tenant from the identity information of the current operator. Define the following filter:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Component
public class TenantFilter implements CacheableFilter<TenantAwareProps> {

    private final TenantProvider tenantProvider;

    public TenantFilter(TenantProvider tenantProvider) {
        this.tenantProvider = tenantProvider;
    }

    @Override
    public void filter(FilterArgs<TenantAwareProps> args) {
        String tenant = tenantProvider.get();
        if (tenant != null) {
            args.where(args.getTable().tenant().eq(tenant));
        }
    }

    @Override
    // highlight-next-line
    public SortedMap<String, Object> getParameters() {
        String tenant = tenantProvider.get();
        if (tenant == null) {
            return null;
        }
        SortedMap<String, Object> map = new TreeMap<>();
        map.put("tenant", tenant);
        return map;
    }

    @Override
    // highlight-next-line  
    public boolean isAffectedBy(EntityEvent<?> e) {
        return e.isChanged(TenantAwareProps.TENANT)
    }
}
```

</TabItem>  
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Component
class TenantFilter(
    private val tenantProvider: TenantProvider  
) : KCacheableFilter<TenantAware> {

    override fun filter(args: KFilterArgs<TenantAware>) {
        tenantProvider.tenant?.let {
            args.apply {
                where(table.tenant.eq(it))
            }
        }
    }

    // highlight-next-line
    overide fun getParameters(): SortedMap<String, Any>? =
        tenantProvider.tenant?.let {
            sortedMapOf("tenant" to it)
        }

    // highlight-next-line
    override fun isAffectedBy(e: EntityEvent<*>): Boolean =
        e.isChanged(TenantAware::tenant)
}
```

</TabItem>
</Tabs>

## Enable Multi-view Cache

We need to enable multi-view cache for association cache and computed cache in `CacheFactory/KCacheFactory`.

This part of the content is exactly the same as discussed in the previous article [Support Built-in Filters](./builtin-filter). It is unnecessary to repeat here.

## SubKey of Computed Properties

We have defined the `getParameters` method in `TenantFilter`. All affected association properties will automatically specify `SubKey` for their association caches. 

However, unfortunately, due to the introduction of user-defined computation rules that the framework cannot understand, developers must manually specify `SubKey` for the `Resolver` implementation of computed properties.

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookStoreAvgPriceResolver.java"
@Component
public class BookStoreAvgPriceResolver implements TransientResolver<Long, BigDecimal> {
    
    private final JSqlClient sqlClient;

    @Override  
    public Ref<SortedMap<String, Object>> getParameterMapRef() {
        return sqlClient
            .getFilters()
            // highlight-next-line
            .getTargetParameterMapRef(BookStoreProps.BOOKS);
    }

    ...code omitted...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookStoreAvgPriceResolver.kt"
@Compoent 
class BookStoreAvgPriceResolver(
    private val sqlClient: KSqlClient
) : KTransientResolver<Long, BigDecimal> {

    override fun getParameterMapRef(): Ref<SortedMap<String, Any>?>? {
        return sqlClient
            .filters
            // highlight-next-line
            .getTargetParameterMapRef(BookStore::books)
    }

    ...code omitted...
}
```

</TabItem>
</Tabs>

Obviously, the computed property `BookStore.avgPrice` is actually determined by the association property `BookStore.books` and changes with it.

Therefore, whatever `SubKey` the association property `BookStore.books` specifies for the multi-view cache system in the current invocation context, the computed property `BookStore.avgPrice` should specify the same one.  

:::note
`BookStore.avgPrice` is also affected by `Book.price`. It changes when `Book.price` changes.

However, `Book.price` is a non-association property of the object, so it must be irrelevant to the multi-view cache system. The `getParameterMapRef` method does not need to consider it here. 
:::

## Usage

Now that we have made the association property `BookStore.books` and the computed property `BookStore.avgPrice` support multi-view caching, let's use object fetchers to query them:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookStoreTable table = BookStoreTable.$;
List<BookStore> stores = sqlClient
    .createQuery(table)
    .select(
        table.fetch(
            BookStoreFetcher.$
                .allScalarFields()
                .books( ‚ù∂
                    BookFetcher.$
                        .allScalarFields()
                )
                .avgPrice() ‚ù∑
        )
    )
    .execute();
System.out.println(stores);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val stores = sqlClient
    .createQuery(BookStore::class) {
        select(
            table.fetchBy {
                allScalarFields()
                books { ‚ù∂
                    allScalarFields()
                }
                avgPrice() ‚ù∑
            }
        )
    }
    .execute()
println(stores)
```

</TabItem>
</Tabs>

:::caution
With the large amount of basics in previous documents, this article intends to simplify the discussion by only showing the data in Redis and the final JSON returned to the user. The SQL generation process is no longer tracked step by step.
:::

The previous article assumed there is an object of type `TenantProvider` in the Spring context. Its Java method `get()` and Kotlin property `tenant` are used to extract the tenant from the identity information of the current operator.

We can execute the above code 3 times, making `TenantProvider` return different information each time to simulate 3 different user identities. 

In the 3 calls, make `TenantProvider` return null, "a" and "b" respectively.

:::info
For the official sample, `TenantProvider` is implemented based on HTTP headers with swagger UI support. It is easy to execute with 3 different user identities.
:::

Open redis-cli. We can verify the data in Redis:

```sh
127.0.0.1:6379> keys BookStore.books-*
1) "BookStore.books-2"  
2) "BookStore.books-1"

127.0.0.1:6379> hgetall BookStore.books-1
1) "{\"tenant\":\"b\"}"
2) "[6,4,2,8]"  
3) "{\"tenant\":\"a\"}"
4) "[5,3,1,9,7]"
5) "{}"
6) "[6,5,4,3,2,1,9,8,7]"

127.0.0.1:6379> hgetall BookStore.books-2
1) "{\"tenant\":\"b\"}"
2) "[12,10]"
3) "{\"tenant\":\"a\"}"  
4) "[11]"
5) "{}"
6) "[12,11,10]"

127.0.0.1:6379> keys BookStore.avgPrice-* 
1) "BookStore.avgPrice-2"
2) "BookStore.avgPrice-1"

127.0.0.1:6379> hgetall BookStore.avgPrice-1
1) "{\"tenant\":\"b\"}"
2) "65.25"
3) "{\"tenant\":\"a\"}"
4) "53.1" 
5) "{}"
6) "58.500000"

127.0.0.1:6379> hgetall BookStore.avgPrice-2
1) "{\"tenant\":\"b\"}"  
2) "80"
3) "{\"tenant\":\"a\"}"
4) "81"
5) "{}"
6) "80.333333" 
```

:::tip
Readers can take a close look at these `redis-cli` commands and easily find that the data of SubKey `{"tenant":"a"}` merged with the data of SubKey `{"tenant":"b"}` is exactly the data of SubKey `{}`. 
:::

The data returned to the user in the 3 calls is: 

<Tabs groupId="language">
<TabItem value="tenant_null" label="filter.tenent=null">  

```json
[
    {
        "id":2,
        "name":"MANNING",  
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":12,
                "name":"GraphQL in Action",
                "edition":3,
                "price":80,
            },
            {
                "id":11,
                ...omitted...
            },
            {
                "id":10,
                ...omitted...
            }
        ],
        // highlight-next-line 
        "avgPrice":80.333333
    },
    {
        "id":1,
        "name":"O'REILLY",
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":6,
                "name":"Effective TypeScript",
                "edition":3,
                "price":88
            },
            {
                "id":5,
                ...omitted...
            },
            {
                "id":4, 
                ...omitted...
            },
            {
                "id":3,
                "name":"Learning GraphQL",
                "edition":3,
                "price":51
            },
            {
                "id":2,
                ...omitted...
            },
            {
                "id":1,
                ...omitted...
            },
            {
                "id":9,
                "name":"Programming TypeScript",
                "edition":3,
                "price":48
            },
            {
                "id":8,
                ...omitted...
            },
            {
                "id":7,
                ...omitted...
            } 
        ],
        // highlight-next-line
        "avgPrice":58.5
    }
]
```

</TabItem>
<TabItem value="tenant_a" label="filter.tenent=a">

```json 
[
    {
        "id":2,
        "name":"MANNING",
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":11,
                "name":"GraphQL in Action",
                "edition":2,
                "price":81
            }
        ],
        // highlight-next-line
        "avgPrice":81
    },
    {
        "id":1,
        "name":"O'REILLY",
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":5,
                "name":"Effective TypeScript",
                "edition":2,
                "price":69
            },
            {
                "id":3,
                ...omitted...
            },
            {
                "id":1,
                ...omitted...
            },
            {
                "id":9,
                ...omitted...
            },
            {
                "id":7,
                ...omitted...
            }
        ],
        // highlight-next-line 
        "avgPrice":53.1
    }
]
```

</TabItem>
<TabItem value="tenant_b" label="filter.tenent=b">

```json
[
    {
        "id":2,
        "name":"MANNING",
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":12,
                "name":"GraphQL in Action",
                "edition":3,
                "price":80
            },
            {
                "id":10,
                ...omitted...
            }
        ],
        // highlight-next-line
        "avgPrice":80
    },
    {
        "id":1,
        "name":"O'REILLY",
        "website":null,
        // highlight-next-line
        "books":[
            {
                "id":6,
                "name":"Effective TypeScript",
                "edition":3,
                "price":88
            },
            {
                "id":4,
                ...omitted...
            },
            {
                "id":2,
                ...omitted...
            },
            {
                "id":8,
                ...omitted...
            }
        ],
        // highlight-next-line
        "avgPrice":65.25
    }
]
```

</TabItem>
</Tabs>

## Consistency  

Now let's modify the `tenant` property of the `Book` object with id 6 from "b" to "a".

Since `Book-6` belongs to `BookStore-1`, it is foreseeable that the multi-view caches corresponding to the properties `BookStore.books-1` and `BookStore.avgPrice-1` will definitely be invalidated.

-   If BinLog trigger is enabled, modifying the database in any way can lead to Jimmer's cache consistency involvement. For example, directly executing the following SQL in SQL IDE:

    ```sql
    update BOOK
    set TENANT = 'a'
    where ID = 6; 
    ```

-   If only Transaction trigger is enabled, the database must be modified using Jimmer's API:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java
    sqlClient.save(
        BookDraft.$.produce(draft -> {
            draft.setId(6L);
            draft.setTenant("a");
        })
    );
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin
    sqlClient.save(
        new(Book::class).by {
            id = 6L
            tenant = "a" 
        }
    )
    ```

    </TabItem>
    </Tabs>

No matter which way above is used to modify the data, you will see the following log output:  

```
Delete data from redis: [Book-6] ‚ù∂
Delete data from redis: [Author.books-3] ‚ù∑  
Delete data from redis: [BookStore.books-1] ‚ù∏
Delete data from redis: [BookStore.avgPrice-1] ‚ùπ
```

-   ‚ù∂ Update object cache of modified entity

-   ‚ù∑ Any association property targeting `Book` must be affected, of course including `Author.books`

    According to existing database data, the affected `Author` object id is 3

-   ‚ù∏ Any association property targeting `Book` must be affected, of course including `BookStore.books`

    According to existing database data, the affected `BookStore` object id is 1   

-   ‚ùπ The computed cache `BookStore.avgPrice` of `BookStore` object with id 1 is also affected. This is the most amazing characteristic.

    Although the framework is unaware of the computation rule used by users in computed properties, in the [Computed Cache](../cache-type/calculation) documentation, we discussed the following code in the `BookStoreAvgPriceResolver` class:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java
    @EventListener
    public void onAssociationChange(AssociationEvent e) {
        if (sqlClient.getCaches().isAffectedBy(e) &&
            // highlight-next-line
            e.isChanged(BookStoreProps.BOOKS)
        ) {
            ...code omitted...
        }
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin
    @EventListener
    fun onAssociationChange(e: AssociationEvent) {
        if (sqlClient.caches.isAffectedBy(e) &&
            // highlight-next-line
            e.isChanged(BookStore::books)
        ) {
            ...code omitted...
        }
    }
    ```

    </TabItem>
    </Tabs>

    If you have forgotten the specific logic of this code, you can review the [Computed Cache](../cache-type/calculation) documentation. Just focus on the highlighted line. Here, this computed property cares about changes to the association property `BookStore.books`.

    :::tip
    Modifying the association field between tables is not the only way to trigger association change events. Modifying the filtered field in associated objects that affects global filters, *like `TENANT` here*, can also trigger association change events.

    This is a very important characteristic of Jimmer's trigger mechanism!
    :::

    It is obvious that ‚ù∏ has already sensed the change of association property `BookStore.books`, so it will further lead to the invalidation of the computed cache here.
