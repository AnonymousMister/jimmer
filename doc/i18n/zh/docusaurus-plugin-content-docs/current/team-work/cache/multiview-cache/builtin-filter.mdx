---
sidebar_position: 2
title: 支持内置过滤器
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 定义软删除标志

Jimmer支持逻辑删除，例如

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book {

    @LogicalDeleted(
        value = "true",
        // highlight-next-line
        useMultiViewCache = true
    )
    boolean isDeleted();

    ...省略其他代码...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
@Entity
interface Book {

    @LogicalDeleted(
        value = "true",
        // highlight-next-line
        useMultiViewCache = true
    )
    val isDeleted: Boolean

    ...省略其他代码...
}
```

</TabItem>
</Tabs>

逻辑删除其实是Jimmer的内置[全局过滤器](../../query/global-filter)，因此，`Book`实体因此被施加了全局过滤器。

一旦实体具备了全局过滤器

-   以`Book`作为目标类型的关联属性。比如，`BookStore.books`、`Author.books`

-   依赖于上述关联属性的计算属性。比如，`BookStore.avgPrice`、`BookStore.newestBooks`*(文档没提及`newestBook`，可参见例子)*

都会受影响。

:::caution
上述代码中的`useMultiViewCache = true`非常重要。

该属性默认值为`false`，表示所有受影响的属性 *（`BookStore.books`、`Author.books`、`BookStore.avgPrice`和`BookStore.newestBooks`）* 均不支持缓存，这是比较保守的选项。

要让这些受影响的属性都支持缓存，必须配置`useMultiViewCache = true`。
:::

## 启用多视图缓存

### 普通的写法

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public CacheFactory cacheFactory(
    RedisConnectionFactory connectionFactory,
    ObjectMapper objectMapper
) {

    RedisTemplate<String, byte[]> redisTemplate = 
        RedisCaches.cacheRedisTemplate(connectionFactory);

    return new CacheFactory() {

        @Override
        public Cache<?, ?> createObjectCache(@NotNull ImmutableType type) {
            ...省略代码...
        }

        @Override
        public Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
            ...省略代码...
        }

        @Override
        public Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
            return createPropCache(
                prop, 
                /* highlight-start */
                prop == BookStoreProps.BOOKS.unwrap() || 
                    prop == AuthorProps.BOOKS.unwrap()
                /* highlight-end */
                Duration.ofMinutes(5)
            );
        }

        @Override
        public Cache<?, ?> createResolverCache(ImmutableProp prop) {
            return createPropCache(
                prop, 
                /* highlight-start */
                prop == BookStoreProps.AVG_PRICE.unwrap() || 
                    prop == BookStoreProps.NEWEST_BOOKS.unwrap()
                /* highlight-end */
                Duration.ofHours(1)
            );
        }

        private <K, V> Cache<K, V> createPropCache(
            ImmutableProp prop, 
            // highlight-next-line
            boolean isMultiviewCache,
            Duration duration
        ) {
            // highlight-next-line
            if (isMultiView) {
                // highlight-next-line
                return new ChainCacheBuilder<K, V>()
                        .add(
                            // highlight-next-line
                            new RedisHashBinder<>(
                                redisTemplate, 
                                objectMapper, 
                                prop, 
                                redisDuration
                            )
                        )
                        .build();
            }

            return new ChainCacheBuilder<>()
                .add(
                    new CaffeineBinder<>(512, Duration.ofSeconds(1))
                )
                .add(
                    new RedisValueBinder<>(
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        duration
                    )
                )
                .build();
        }
    };
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun cacheFactory(
    connectionFactory: RedisConnectionFactory,
    objectMapper: ObjectMapper
): KCacheFactory {

    val redisTemplate = RedisCaches.cacheRedisTemplate(connectionFactory)

    return object: KCacheFactory {

        override fun createObjectCache(type: ImmutableType): Cache<*, *>? =
            ...省略代码...

        override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =
            ...省略代码...

        override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =
            createPropCache(
                prop,
                /* highlight-start */
                prop === BookStore::books.toImmutableProp() ||
                    prop === Author::authors.toImmutableProp(), 
                /* highlight-end */
                Duration.ofHours(1)
            )

        override fun createResolverCache(prop: ImmutableProp): Cache<*, *> =
            createPropCache(
                prop,
                /* highlight-start */
                prop === BookStore::avgPrice.toImmutableProp() ||
                    prop === BookStore::newestBooks.toImmutableProp(), 
                /* highlight-end */
                Duration.ofHours(1)
            )

        private fun <K, V> createPropCache(
            prop: ImmutableProp, 
            // highlight-next-line
            isMultiView: Boolean,
            duration: Duration
        ): Cache<K, V> {
            // highlight-next-line
            if (isMultiView) {
                return ChainCacheBuilder<K, V>()
                        .add(
                            // highlight-next-line
                            RedisHashBinder<>(
                                redisTemplate, 
                                objectMapper, 
                                prop, 
                                redisDuration
                            )
                        )
                        .build();
            }
            ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(512, Duration.ofSeconds(1))
                )
                .add(
                    RedisValueBinder(
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        duration
                    )
                )
                .build()
        }
    }
}
```

</TabItem>
</Tabs>

上面的代码中`RedisHashBinder`是非常重要的实现类，利用redis支持多视图缓存，其背后存储结构对应[Redis Hashes](https://redis.io/docs/data-types/hashes/)，即，嵌套的Hash结构。

<table>
    <thead>
        <tr>
            <th>缓存技术风格</th>
            <th>多视图</th>
            <th>抽象接口❶</th>
            <th>内置实现❷</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2">
                支持自Loading的缓存
                <div><i>(通常是一级缓存技术：比如Guava, Caffine)</i></div>
            </td>
            <td>
                否
            </td>
            <td>
                LoadingBinder&lt;K, V&gt;
            </td>
            <td>
                CaffeineBinder&lt;K, V&gt;
            </td>
        </tr>
        <tr>
            <td>
                是
            </td>
            <td>
                LoadingBinder.Parameterized&lt;K, V&gt;
            </td>
            <td>
                无
            </td>
        </tr>
        <tr>
            <td rowspan="2">
                不支持自Loading的缓存
                <div><i>(通常是二级缓存技术：比如Redis)</i></div>
            </td>
            <td>
                否
            </td>
            <td>
                SimpleBinder&lt;K, V&gt;
            </td>
            <td>
                RedisValueBinder&lt;K, V&gt;
            </td>
        </tr>
        <tr>
            <td>
                是
            </td>
            <td>
                SimpleBinder.Parameterized&lt;K, V&gt;
            </td>
            <td>
                <b>RedisHashBinder&lt;K, V&gt;</b>
            </td>
        </tr>
    </tbody>
</table>

-   ❶ 抽象接口：所在项目为`jimmer-sql`，所在的包为`org.babyfish.jimmer.sql.cache.chain`

-   ❷ 内置实现：所在项目为`jimmer-spring-boot-starter`，所在的包为`org.babyfish.jimmer.spring.cache`

:::caution
目前，暂时没有`Caffeine`的多视图缓存实现。所以，上述代码中，多视图缓存仅针对Redis。即，多视图模式下，缓存只有一级，而非两级别。
:::

### 更好的方法

在上面的代码中，`createAssociatedIdCache`和`createAssociatedIdListCache`方法内部对参数`prop`进行判断，以决定究竟应该构建多视图缓存还是单视图缓存。

:::tip
:::
