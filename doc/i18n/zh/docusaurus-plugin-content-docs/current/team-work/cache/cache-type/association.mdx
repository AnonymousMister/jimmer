---
sidebar_position: 2
title: 关联缓存
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ViewMore } from '@site/src/components/ViewMore';

所谓对象缓存，指把当前对象id映射为关联对象id或集合。

![object-cache](@site/static/img/association-cache.png)

其中
-   `BookStore.books-*`: 一对多关联缓存
-   `Book.store-*`: 多对一关联缓存
-   `Book.authors-*`: 多对多关联缓存
-   `Author.books-*`: 多对多关联缓存

:::caution
和其他关联缓存不同，有一种场景不需要使用一对一或多对一关联缓存。

如果一对一或多对一关联基于真实外键，在数据库中存在对应的外间约束，那么外键本身就是关联对象id，无需使用关联缓存。

其他情况下，Jimmer都会使用一对一或多对一关联缓存，这些情况包括

-   关联属性是反向映射

    即`@OneToOne`或`@ManyToOne`的`mappedBy`被配置

-   关联属性基于伪外键

    所谓伪外键，即在开发人员意识中是外键，但是数据库中并没有对应的外建约束

    伪外键字段可能是非法值，非null并不意味着关联对象的存在，所以，需要用关联缓存过滤得到合法的关联对象

-   关联属性基于中间表，而非基于外建

-   对于已经存在的Jimmer对象，在其一对一或多对一关属性缺时加载一对一或多一关联对象

    这种特殊的案例，在[用Jimmer实现GraphQL](../../graphql)时会出现，其他情况下基本不会出现
:::

在附带的官方示例子中，多对一关联`Book.store`基于真实外建，所以，其多对一缓存不会被使用。

因此，本文的例子基于一对多关联`BookStore.books`和多对多关联`Book.authors`。

## 启用关联缓存

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public CacheFactory cacheFactory(
    RedisConnectionFactory connectionFactory,
    ObjectMapper objectMapper
) {

    RedisTemplate<String, byte[]> redisTemplate = 
        RedisCaches.cacheRedisTemplate(connectionFactory);

    return new CacheFactory() {

        @Override
        @Nullable
        public Cache<?, ?> createObjectCache(@NotNull ImmutableType type) {
            ...省略代码...
        }

        // 将当前对象id映射为关联对象id
        // 适用于一对一和多对一关联属性
        // highlight-next-line
        public Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
            return createPropCache(prop, Duration.ofMinutes(10));
        }

        // 将当前对象id映射为关联对象id集合
        // 适用于一对多和多对多关联属性
        // highlight-next-line
        public Cache<?, ?> createAssociatedIdCache(@NotNull ImmutableProp prop) {
            return createPropCache(prop, Duration.ofMinutes(5));
        }

        private Cache<?, ?> createPropCache(ImmutableProp prop, Duration duration) {
            return new ChainCacheBuilder<>()
                .add(
                    new CaffeineBinder<>(512, Duration.ofSeconds(1))
                )
                .add(
                    new RedisValueBinder<>(
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        duration
                    )
                )
                .build();
        }

        ...省略其他代码...
    };
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun cacheFactory(
    connectionFactory: RedisConnectionFactory,
    objectMapper: ObjectMapper
): KCacheFactory {

    val redisTemplate = RedisCaches.cacheRedisTemplate(connectionFactory)

    return object: KCacheFactory {

        override fun createObjectCache(type: ImmutableType): Cache<*, *>? =
            ...省略代码...

        // 将当前对象id映射为关联对象id
        // 适用于一对一和多对一关联属性
        // highlight-next-line
        override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =
            createPropCache(prop, Duration.ofMinutes(10))

        // 将当前对象id映射为关联对象id集合
        // 适用于一对多和多对多关联属性
        // highlight-next-line
        override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =
            createPropCache(prop, Duration.ofMinutes(5))

        private fun createPropCache(type: ImmutableType, duration: Duration): Cache<*, *> =
            ChainCacheBuilder<Any, Any>()
                .add(
                    CaffeineBinder(512, Duration.ofSeconds(1))
                )
                .add(
                    RedisValueBinder(
                        redisTemplate, 
                        objectMapper, 
                        prop, 
                        Duration.ofMinutes(10)
                    )
                )
                .build()

        ...省略其他代码...
    }
}
```

</TabItem>
</Tabs>