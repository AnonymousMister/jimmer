-   多线程安全性，这点很好理解，不用解释。

-   对于Set、Map这类依赖hashCode的集合容器而言，迫切需要对象的不可变性。

    一旦集合容器保存了可变对象，开发人员就必须小心翼翼地确保不去修改被这些容器共享的数据。如果不慎犯了错误，通常需要debug跟踪来发现问题，这往往会浪费时间影响效率。

-   实际开发中还有一些长期持有对象的场合场合，虽然不依赖hashCode，但也会因长期持有对象而导致问题，比如：

    -   利用WebSession中长期持有某些数据

    -   利用一级缓存，即，使用JVM内存的进程内缓存，长期持有某些数据

    细心的开发人员肯定不希望WebSession或Cache中被长期持有数据的引用和泄漏到用户代码中的引用共享数据结构，进而导致不可控的彼此干扰。

    因此，对WebSession或JVM内部Cache这类长期持有数据的结构进行读写操作时，细心的开发人员会将可变数据结构复制一次再进行保存或返回。其中，写入时复制尚可接受，但每次读取都复制一次显得昂贵。可见

    -   使用可变对象，是否需要复制对象以保证必要安全性，依赖于开发人员的风险预知能力，这需要开发人员有一定经验并生性谨慎。然而，即便预知了风险，解决之道也没有客观标准，过于严格会导致过多不必要复制，形成浪费，过于宽松会导致复制不足，出现BUG *(团队人数越多，越容易出错)*。而且，对于有一定体量的数据而言，团队内部对这种保护机制的严格程度也常有争论，具备很强的主观性。

    -   使用可不变对象，只有数据结构被“修改” *(这里的修改是伪修改，并非真正的修改当前数据，后续文档会详细讨论之)* 时才复制部分数据 *(Jimmer/Immer内部对此有优化，被修改的对象会被复制，从其上级对象开始到根节点为止的所有祖先节点也会被复制，然而，其余所有未变的分支仍然共享重用)* 得到新的聚合根引用，其余情况一律简单共享原始引用即可。具备非常严格的无可争议的客观性。

    :::tip
    毫无疑问，基于客观规律进行开发，必然优于基于主观感觉进行开发，这非常重要。
    :::

    其实，这也说明了一个问题：数据库这类很重量级的资源比较特殊，开发人员会允许并故意利用多方修改带来的彼此影响；然而，对于其他更细枝末节的普通对象资源，只要其职责并非状态机 *(如同数据库一样，其很大一部分存在价值就是被修改)*，开发人员就应该通过不可变性尽可能消除多方修改带来的彼此影响，消除这种彼此影响可以带来良好的普适性、健壮性和开发体验。