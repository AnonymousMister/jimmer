---
sidebar_position: 1
title: 用法
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Jimmer分页的特色

分页查询是Jimmer一个很有特色的的功能，能大幅提升开发效率。

分页需要执行两条SQL查询

-   查询满足条件的数据总行数，其结果可以计算一共有多少页，用户的页码是否越界。

    :::info
    为了便于讨论，Jimmer称这条SQL为`count-query`
    :::

-   查询当前页内的所有数据，返回的数据条数不超过页面大小，并跳过之前页的所有数据。

    :::info
    为了便于讨论，Jimmer称这条SQL为`data-query`
    :::

:::tip
Jimer分页的特色：开发人员只需编写`data-query`，框架自动生成`count-query`。
:::

另外，`count-query`其实是可以优化的。

让我们来看一个可以优化的场景，在data-query中有存在一个JOIN，如果它同满足如下面的条件

-   此JOIN操作得到的表，并没有被`where`条件使用，而是在其他不会影响记录行数的地方被使用，比如`orderBy`

-   此JOIN的方向是从子表指向父表 *(即多对一和一对一关联)*，连接结果不会出现数据重复。也就是说，此JOIN不会导致数据变多

-   此JOIN的外建是真的 *(即存在外建约束，请参见[真假外建](../../mapping/base/foreignkey))* 且非null。那么此JOIN不会导致数据变少

则可以安全地从count-query中剔除它，达到优化目的

:::tip
Jimmer不但可以自动生成`count-query`，还可以做的优化`count-query`
:::

## 配合SpringBoot使用时

配合SpringBoot使用时，开发人员从`JRepository/KRepository`派生自定义的Repository接口，为自定义接口添加查询方法有两种选择

-   按照一定的约定声明抽象方法，交由Jimmer自动实现

    :::caution
    这种用法过于简单，隐藏了所有细节，不适在此讲述分页查询。
    
    你可以查看[Spring篇/SpringData风格/抽象方法](../../spring/repository/abstract)以了解如何通过这种方式实现分页查询
    :::

-   直接在自定义接口中定义default方法，自己实现查询逻辑

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookRepository.java"

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
...省略其他导入...

public interface BookRepository<Book, Long> extends JRepository<Book, Long> {

    BookTable table = BookTable.$;

    default public Page<Book> findBooks(
        Pageable pageable,
        @Nullable String name,
        @Nullable String storeName
    ) {
        return pager(pageable).excute( ❶
            sql()
                .createQuery(table)
                .whereIf(
                    name != null && !name.isEmpty(),
                    table.name().eq(name)
                )
                .whereIf(
                    storeName != null && !storeName.isEmpty(),
                    table.store().name().eq(storeName)
                )
                .orderBy(SpringOrders.toOrders(table, pageable.getSort())) ❷
                .select(table)
                ❸
        );
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookRepository.kt"
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
...省略其他导入...

interface BookRepository<Book, Long> : KRepository<Book, Long> {

    fun findBooks(
        pageable: Pageable,
        name: String? = null,
        storeName: String? = null
    ): Page<Book> =
        pager(pageable).excute( ❶
            sql
                .createQuery(Book::class) {
                    name?.takeIf { it.isNotEmpty() }?.let {
                        where(table.name eq it)
                    }
                    storeName?.takeIf { it.isNotEmpty() }?.let {
                        where(table.store.name eq it)
                    }
                    orderBy(pageable.sort) ❷
                    select(table)
                } ❸
        )
}
```

</TabItem>
</Tabs>

-   ❶ 调用超接口的`pager`方法创建一个辅助对象，并调用该对象的方法`execute`实现分页查询。

    `execute`的参数是一个未执行的查询，该查询作为`data-query`的模板。
    
    -   首先，由于`data-query`模板尚未执行，Jimmer有机会根据它自动创建`count-query`，查询出分页前的数据总行数。

    -   然后，Jimmer在`data-query`模板的基础上，添加分页范围，创建真正的`data-query`，查询当前页类的数据。

    -   最后，Jimmer将数据总行数和当前页类的数据组合，创建Spring Data的`Page`对象并返回。

-   ❷ 由于Spring Data的`Pageabe`包含了动态排序，所以需要应用动态排序

-   ❸ `select`之后并没有调用查询本身的`execute`，说明这是一个未执行的查询。

如果我们执行

```java
findBooks(
    PageRequest.of(1, 5, "name asc, edition desc"),
    null,
    null
)
```

:::caution
SpringData中`Pageabe`的页码从0开始，而非从1开始，所以，这里查询的是第二页
:::

会生成两条SQL

-   count-query

    ```sql
    select
        count(tb_1_.ID)
    from BOOK tb_1_
    ```

-   data-query *（假设数据库是H2）*

    ```sql
    select
        tb_1_.ID,
        tb_1_.CREATED_TIME,
        tb_1_.MODIFIED_TIME,
        tb_1_.NAME,
        tb_1_.EDITION,
        tb_1_.PRICE,
        tb_1_.STORE_ID
    from BOOK tb_1_
    order by
        tb_1_.NAME asc,
        tb_1_.EDITION desc
    limit ? /* 5 */, ? /* 5 */
    ```

这个例子可以让我们明白Jimmer分页功能，但是，Jimmer的Spring API隐藏了一些细节。因此，接下来，我们绕开Spring Boot，从更底层的角度更清晰地阐述。

## 不配合SpringBoot使用时